"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/auth/supabase/sign-in/page",{

/***/ "(app-pages-browser)/./src/auth/context/supabase/action.ts":
/*!*********************************************!*\
  !*** ./src/auth/context/supabase/action.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signInWithPassword: function() { return /* binding */ signInWithPassword; },\n/* harmony export */   signOut: function() { return /* binding */ signOut; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; }\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-helpers-nextjs */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ signInWithPassword,signUp,signOut auto */ \n/** **************************************\n * Supabase client\n *************************************** */ const supabase = (0,_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__.createClientComponentClient)();\n/** **************************************\n * Sign in\n *************************************** */ const signInWithPassword = async (param)=>{\n    let { email, password } = param;\n    var _data_session;\n    const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (error) {\n        console.error(\"Error during sign in:\", error);\n        throw error;\n    }\n    if (!((_data_session = data.session) === null || _data_session === void 0 ? void 0 : _data_session.access_token)) {\n        throw new Error(\"Access token not found in response\");\n    }\n    // Here you can set the supabase session, which will be handled by supabase-helpers\n    console.log(\"Signed in successfully with access token:\", data.session.access_token);\n};\n/** **************************************\n * Sign up\n *************************************** */ const signUp = async (param)=>{\n    let { email, password } = param;\n    var _data_session;\n    const { data, error } = await supabase.auth.signUp({\n        email,\n        password\n    });\n    if (error) {\n        console.error(\"Error during sign up:\", error);\n        throw error;\n    }\n    if (!((_data_session = data.session) === null || _data_session === void 0 ? void 0 : _data_session.access_token)) {\n        throw new Error(\"Access token not found in response\");\n    }\n    sessionStorage.setItem(\"supabase.auth.token\", data.session.access_token);\n};\n/** **************************************\n * Sign out\n *************************************** */ const signOut = async ()=>{\n    const { error } = await supabase.auth.signOut();\n    if (error) {\n        console.error(\"Error during sign out:\", error);\n        throw error;\n    }\n    console.log(\"Signed out successfully\");\n}; /** **************************************\n * Sign in\n *************************************** */  // export const signInWithPassword = async ({ email, password }: SignInParams): Promise<void> => {\n //   try {\n //     const params = { email, password };\n //     const res = await axios.post(endpoints.auth.signIn, params);\n //     const { accessToken } = res.data;\n //     if (!accessToken) {\n //       throw new Error('Access token not found in response');\n //     }\n //     setSession(accessToken);\n //   } catch (error) {\n //     console.error('Error during sign in:', error);\n //     throw error;\n //   }\n // };\n /** **************************************\n * Sign up\n *************************************** */  // export const signUp = async ({\n //   email,\n //   password,\n //   firstName,\n //   lastName,\n // }: SignUpParams): Promise<void> => {\n //   const params = {\n //     email,\n //     password,\n //     firstName,\n //     lastName,\n //   };\n //   try {\n //     const res = await axios.post(endpoints.auth.signUp, params);\n //     const { accessToken } = res.data;\n //     if (!accessToken) {\n //       throw new Error('Access token not found in response');\n //     }\n //     sessionStorage.setItem(STORAGE_KEY, accessToken);\n //   } catch (error) {\n //     console.error('Error during sign up:', error);\n //     throw error;\n //   }\n // };\n /** **************************************\n * Sign out\n *************************************** */  // export const signOut = async (): Promise<void> => {\n //   try {\n //     await setSession(null);\n //   } catch (error) {\n //     console.error('Error during sign out:', error);\n //     throw error;\n //   }\n // };\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hdXRoL2NvbnRleHQvc3VwYWJhc2UvYWN0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3VGQUU0RTtBQXFCNUU7O3lDQUV5QyxHQUN6QyxNQUFNQyxXQUFXRCwwRkFBMkJBO0FBRTVDOzt5Q0FFeUMsR0FDbEMsTUFBTUUscUJBQXFCO1FBQU8sRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQWdCO1FBUW5FQztJQVBMLE1BQU0sRUFBRUEsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNTCxTQUFTTSxJQUFJLENBQUNMLGtCQUFrQixDQUFDO1FBQUVDO1FBQU9DO0lBQVM7SUFFakYsSUFBSUUsT0FBTztRQUNURSxRQUFRRixLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxNQUFNQTtJQUNSO0lBRUEsSUFBSSxHQUFDRCxnQkFBQUEsS0FBS0ksT0FBTyxjQUFaSixvQ0FBQUEsY0FBY0ssWUFBWSxHQUFFO1FBQy9CLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLG1GQUFtRjtJQUNuRkgsUUFBUUksR0FBRyxDQUFDLDZDQUE2Q1AsS0FBS0ksT0FBTyxDQUFDQyxZQUFZO0FBQ3BGLEVBQUU7QUFDRjs7eUNBRXlDLEdBQ2xDLE1BQU1HLFNBQVM7UUFBTyxFQUFFVixLQUFLLEVBQUVDLFFBQVEsRUFBZ0I7UUFRdkRDO0lBUEwsTUFBTSxFQUFFQSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1MLFNBQVNNLElBQUksQ0FBQ00sTUFBTSxDQUFDO1FBQUVWO1FBQU9DO0lBQVM7SUFFckUsSUFBSUUsT0FBTztRQUNURSxRQUFRRixLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxNQUFNQTtJQUNSO0lBRUEsSUFBSSxHQUFDRCxnQkFBQUEsS0FBS0ksT0FBTyxjQUFaSixvQ0FBQUEsY0FBY0ssWUFBWSxHQUFFO1FBQy9CLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBRyxlQUFlQyxPQUFPLENBQUMsdUJBQXVCVixLQUFLSSxPQUFPLENBQUNDLFlBQVk7QUFDekUsRUFBRTtBQUNGOzt5Q0FFeUMsR0FDbEMsTUFBTU0sVUFBVTtJQUNyQixNQUFNLEVBQUVWLEtBQUssRUFBRSxHQUFHLE1BQU1MLFNBQVNNLElBQUksQ0FBQ1MsT0FBTztJQUU3QyxJQUFJVixPQUFPO1FBQ1RFLFFBQVFGLEtBQUssQ0FBQywwQkFBMEJBO1FBQ3hDLE1BQU1BO0lBQ1I7SUFFQUUsUUFBUUksR0FBRyxDQUFDO0FBQ2QsRUFBRSxDQUNGOzt5Q0FFeUMsSUFDekMsa0dBQWtHO0NBQ2xHLFVBQVU7Q0FDViwwQ0FBMEM7Q0FFMUMsbUVBQW1FO0NBRW5FLHdDQUF3QztDQUV4QywwQkFBMEI7Q0FDMUIsK0RBQStEO0NBQy9ELFFBQVE7Q0FFUiwrQkFBK0I7Q0FDL0Isc0JBQXNCO0NBQ3RCLHFEQUFxRDtDQUNyRCxtQkFBbUI7Q0FDbkIsTUFBTTtDQUNOLEtBQUs7Q0FFTDs7eUNBRXlDLElBQ3pDLGlDQUFpQztDQUNqQyxXQUFXO0NBQ1gsY0FBYztDQUNkLGVBQWU7Q0FDZixjQUFjO0NBQ2QsdUNBQXVDO0NBQ3ZDLHFCQUFxQjtDQUNyQixhQUFhO0NBQ2IsZ0JBQWdCO0NBQ2hCLGlCQUFpQjtDQUNqQixnQkFBZ0I7Q0FDaEIsT0FBTztDQUVQLFVBQVU7Q0FDVixtRUFBbUU7Q0FFbkUsd0NBQXdDO0NBRXhDLDBCQUEwQjtDQUMxQiwrREFBK0Q7Q0FDL0QsUUFBUTtDQUVSLHdEQUF3RDtDQUN4RCxzQkFBc0I7Q0FDdEIscURBQXFEO0NBQ3JELG1CQUFtQjtDQUNuQixNQUFNO0NBQ04sS0FBSztDQUVMOzt5Q0FFeUMsSUFDekMsc0RBQXNEO0NBQ3RELFVBQVU7Q0FDViw4QkFBOEI7Q0FDOUIsc0JBQXNCO0NBQ3RCLHNEQUFzRDtDQUN0RCxtQkFBbUI7Q0FDbkIsTUFBTTtDQUNOLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2F1dGgvY29udGV4dC9zdXBhYmFzZS9hY3Rpb24udHM/ZjUzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtbmV4dGpzJztcblxuaW1wb3J0IGF4aW9zLCB7IGVuZHBvaW50cyB9IGZyb20gJ3NyYy91dGlscy9heGlvcyc7XG5cbmltcG9ydCB7IHNldFNlc3Npb24gfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFNUT1JBR0VfS0VZIH0gZnJvbSAnLi9jb25zdGFudCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IHR5cGUgU2lnbkluUGFyYW1zID0ge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgU2lnblVwUGFyYW1zID0ge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBmaXJzdE5hbWU6IHN0cmluZztcbiAgbGFzdE5hbWU6IHN0cmluZztcbn07XG5cbi8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogU3VwYWJhc2UgY2xpZW50XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5jb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCgpO1xuXG4vKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNpZ24gaW5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmV4cG9ydCBjb25zdCBzaWduSW5XaXRoUGFzc3dvcmQgPSBhc3luYyAoeyBlbWFpbCwgcGFzc3dvcmQgfTogU2lnbkluUGFyYW1zKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHsgZW1haWwsIHBhc3N3b3JkIH0pO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBzaWduIGluOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmICghZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY2VzcyB0b2tlbiBub3QgZm91bmQgaW4gcmVzcG9uc2UnKTtcbiAgfVxuXG4gIC8vIEhlcmUgeW91IGNhbiBzZXQgdGhlIHN1cGFiYXNlIHNlc3Npb24sIHdoaWNoIHdpbGwgYmUgaGFuZGxlZCBieSBzdXBhYmFzZS1oZWxwZXJzXG4gIGNvbnNvbGUubG9nKCdTaWduZWQgaW4gc3VjY2Vzc2Z1bGx5IHdpdGggYWNjZXNzIHRva2VuOicsIGRhdGEuc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xufTtcbi8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogU2lnbiB1cFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZXhwb3J0IGNvbnN0IHNpZ25VcCA9IGFzeW5jICh7IGVtYWlsLCBwYXNzd29yZCB9OiBTaWduVXBQYXJhbXMpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduVXAoeyBlbWFpbCwgcGFzc3dvcmQgfSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHNpZ24gdXA6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYgKCFkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignQWNjZXNzIHRva2VuIG5vdCBmb3VuZCBpbiByZXNwb25zZScpO1xuICB9XG5cbiAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnc3VwYWJhc2UuYXV0aC50b2tlbicsIGRhdGEuc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xufTtcbi8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogU2lnbiBvdXRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmV4cG9ydCBjb25zdCBzaWduT3V0ID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgc2lnbiBvdXQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ1NpZ25lZCBvdXQgc3VjY2Vzc2Z1bGx5Jyk7XG59O1xuLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTaWduIGluXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBleHBvcnQgY29uc3Qgc2lnbkluV2l0aFBhc3N3b3JkID0gYXN5bmMgKHsgZW1haWwsIHBhc3N3b3JkIH06IFNpZ25JblBhcmFtcyk6IFByb21pc2U8dm9pZD4gPT4ge1xuLy8gICB0cnkge1xuLy8gICAgIGNvbnN0IHBhcmFtcyA9IHsgZW1haWwsIHBhc3N3b3JkIH07XG5cbi8vICAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5wb3N0KGVuZHBvaW50cy5hdXRoLnNpZ25JbiwgcGFyYW1zKTtcblxuLy8gICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4gfSA9IHJlcy5kYXRhO1xuXG4vLyAgICAgaWYgKCFhY2Nlc3NUb2tlbikge1xuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2Nlc3MgdG9rZW4gbm90IGZvdW5kIGluIHJlc3BvbnNlJyk7XG4vLyAgICAgfVxuXG4vLyAgICAgc2V0U2Vzc2lvbihhY2Nlc3NUb2tlbik7XG4vLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4vLyAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHNpZ24gaW46JywgZXJyb3IpO1xuLy8gICAgIHRocm93IGVycm9yO1xuLy8gICB9XG4vLyB9O1xuXG4vKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNpZ24gdXBcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIGV4cG9ydCBjb25zdCBzaWduVXAgPSBhc3luYyAoe1xuLy8gICBlbWFpbCxcbi8vICAgcGFzc3dvcmQsXG4vLyAgIGZpcnN0TmFtZSxcbi8vICAgbGFzdE5hbWUsXG4vLyB9OiBTaWduVXBQYXJhbXMpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbi8vICAgY29uc3QgcGFyYW1zID0ge1xuLy8gICAgIGVtYWlsLFxuLy8gICAgIHBhc3N3b3JkLFxuLy8gICAgIGZpcnN0TmFtZSxcbi8vICAgICBsYXN0TmFtZSxcbi8vICAgfTtcblxuLy8gICB0cnkge1xuLy8gICAgIGNvbnN0IHJlcyA9IGF3YWl0IGF4aW9zLnBvc3QoZW5kcG9pbnRzLmF1dGguc2lnblVwLCBwYXJhbXMpO1xuXG4vLyAgICAgY29uc3QgeyBhY2Nlc3NUb2tlbiB9ID0gcmVzLmRhdGE7XG5cbi8vICAgICBpZiAoIWFjY2Vzc1Rva2VuKSB7XG4vLyAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY2VzcyB0b2tlbiBub3QgZm91bmQgaW4gcmVzcG9uc2UnKTtcbi8vICAgICB9XG5cbi8vICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBhY2Nlc3NUb2tlbik7XG4vLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4vLyAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHNpZ24gdXA6JywgZXJyb3IpO1xuLy8gICAgIHRocm93IGVycm9yO1xuLy8gICB9XG4vLyB9O1xuXG4vKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNpZ24gb3V0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBleHBvcnQgY29uc3Qgc2lnbk91dCA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbi8vICAgdHJ5IHtcbi8vICAgICBhd2FpdCBzZXRTZXNzaW9uKG51bGwpO1xuLy8gICB9IGNhdGNoIChlcnJvcikge1xuLy8gICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBzaWduIG91dDonLCBlcnJvcik7XG4vLyAgICAgdGhyb3cgZXJyb3I7XG4vLyAgIH1cbi8vIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50Iiwic3VwYWJhc2UiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJlbWFpbCIsInBhc3N3b3JkIiwiZGF0YSIsImVycm9yIiwiYXV0aCIsImNvbnNvbGUiLCJzZXNzaW9uIiwiYWNjZXNzX3Rva2VuIiwiRXJyb3IiLCJsb2ciLCJzaWduVXAiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJzaWduT3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/auth/context/supabase/action.ts\n"));

/***/ })

});